/*
 * AggregationUTest.cxxtest
 *
 * Copyright (C) 2020 Linas Vepstas <linasvepstas@gmail.com>
 * All Rights Reserved
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */

#include <opencog/atoms/atom_types/atom_types.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/guile/SchemeEval.h>
#include <opencog/generate/Aggregate.h>
#include <opencog/generate/DefaultCallback.h>

#include <cxxtest/TestSuite.h>

using namespace opencog;

#define al as->add_link
#define an as->add_node

class AggregationUTest: public CxxTest::TestSuite
{
private:
	AtomSpace* as;
	SchemeEval* eval;
	Aggregate* ag;

public:
	AggregationUTest();
	~AggregationUTest();

	void setUp();
	void tearDown();

	void test_hello();
	void test_tree();
	void xtest_loop();
};

AggregationUTest::AggregationUTest()
{
	logger().set_level(Logger::DEBUG);
	logger().set_print_to_stdout_flag(true);
	logger().set_timestamp_flag(false);
}

AggregationUTest::~AggregationUTest()
{
	logger().info("Completed running UnorderedUTest");

	// erase the log file if no assertions failed
	if (!CxxTest::TestTracker::tracker().suiteFailed())
		std::remove(logger().get_filename().c_str());
	else
	{
		logger().info("AggregationUTest failed!");
		logger().flush();
	}
}

void AggregationUTest::setUp()
{
	as = new AtomSpace();
	eval = new SchemeEval(as);
	eval->eval("(add-to-load-path \"" PROJECT_SOURCE_DIR "\")");
	ag = new Aggregate(as);
}

void AggregationUTest::tearDown()
{
	delete ag;
	delete eval;
	delete as;
}

// Single generation: "Hello world"
void AggregationUTest::test_hello()
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

	eval->eval("(load-from-path \"tests/generate/dict-helloworld.scm\")");
	Handle wall = eval->eval_h("left-wall");

	// The directions to connect.
	Handle plus = an(CONNECTOR_DIR_NODE, "+");
	Handle minus = an(CONNECTOR_DIR_NODE, "-");
	HandlePairSeq pole_pairs;
	pole_pairs.push_back({minus, plus});
	pole_pairs.push_back({plus, minus});
	DefaultCallback cb(as, pole_pairs);

	Handle result = ag->aggregate({wall}, cb);

	TSM_ASSERT("Bad result!", result != Handle::UNDEFINED);

	printf("Hello-world result is  %s\n", result->to_string().c_str());
	TSM_ASSERT("Bad result set!", result->get_arity() == 1);
	Handle soln = result->getOutgoingAtom(0);

	TSM_ASSERT("Bad section!", soln->get_arity() == 3);

	// We expect the soultion to be LEFT_WALL --W--> Hello --OH--> world

	logger().debug("END TEST: %s", __FUNCTION__);
}

// Four generations: "John/Sue saw a bird/cat", as an acyclic tree.
void AggregationUTest::test_tree()
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

	eval->eval("(load-from-path \"tests/generate/dict-tree.scm\")");
	Handle wall = eval->eval_h("left-wall");

	// The directions to connect.
	Handle plus = an(CONNECTOR_DIR_NODE, "+");
	Handle minus = an(CONNECTOR_DIR_NODE, "-");
	HandlePairSeq pole_pairs;
	pole_pairs.push_back({minus, plus});
	pole_pairs.push_back({plus, minus});
	DefaultCallback cb(as, pole_pairs);

	Handle result = ag->aggregate({wall}, cb);

	TSM_ASSERT("Bad result!", result != Handle::UNDEFINED);

	printf("Tree result is  %s\n", result->to_string().c_str());
	TSM_ASSERT("Bad result set!", result->get_arity() == 4);
	Handle soln = result->getOutgoingAtom(0);

	TSM_ASSERT("Bad section!", soln->get_arity() == 5);

	// We expect the soultion to be loop-free (acyclic)
	//                    +----O-----+
	//    +--->W---+---S--+    +--D--+
	//    |        |      |    |     |
	// LEFT-WALL John    saw   a    cat

	logger().debug("END TEST: %s", __FUNCTION__);
}

// Four generations: "John/Sue saw a bird/cat", as graph w/ cycles.
// Currently failig due to inf recursion.
void AggregationUTest::xtest_loop()
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

	eval->eval("(load-from-path \"tests/generate/dict-loop.scm\")");
	Handle wall = eval->eval_h("left-wall");

logger().set_level(Logger::FINE);
	// The directions to connect.
	Handle plus = an(CONNECTOR_DIR_NODE, "+");
	Handle minus = an(CONNECTOR_DIR_NODE, "-");
	HandlePairSeq pole_pairs;
	pole_pairs.push_back({minus, plus});
	pole_pairs.push_back({plus, minus});
	DefaultCallback cb(as, pole_pairs);

	Handle result = ag->aggregate({wall}, cb);

	TSM_ASSERT("Bad result!", result != Handle::UNDEFINED);

	printf("Loop result is  %s\n", result->to_string().c_str());
	TSM_ASSERT("Bad result set!", result->get_arity() == 4);
	Handle soln = result->getOutgoingAtom(0);

	TSM_ASSERT("Bad section!", soln->get_arity() == 5);

	// We expect the soultion to be have a loop
	//    +-------WV------+----O-----+
	//    +--->W---+---S--+    +--D--+
	//    |        |      |    |     |
	// LEFT-WALL John    saw   a    cat

	logger().debug("END TEST: %s", __FUNCTION__);
}
