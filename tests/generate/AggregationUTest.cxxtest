/*
 * AggregationUTest.cxxtest
 *
 * Copyright (C) 2020 Linas Vepstas <linasvepstas@gmail.com>
 * All Rights Reserved
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */

#include <opencog/atoms/atom_types/atom_types.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/guile/SchemeEval.h>
#include <opencog/generate/Aggregate.h>
#include <opencog/generate/DefaultCallback.h>

#include <cxxtest/TestSuite.h>

using namespace opencog;

#define al as->add_link
#define an as->add_node

class AggregationUTest: public CxxTest::TestSuite
{
private:
	AtomSpace* as;
	SchemeEval* eval;
	Aggregate* ag;
	Dictionary* dict;

public:
	AggregationUTest();
	~AggregationUTest();

	void setUp();
	void tearDown();

	void setup_dict();

	void test_hello();
	void test_tree();
	void test_loop();
};

AggregationUTest::AggregationUTest()
{
	logger().set_level(Logger::DEBUG);
	logger().set_print_to_stdout_flag(true);
	logger().set_timestamp_flag(false);
}

AggregationUTest::~AggregationUTest()
{
	logger().info("Completed running UnorderedUTest");

	// erase the log file if no assertions failed
	if (!CxxTest::TestTracker::tracker().suiteFailed())
		std::remove(logger().get_filename().c_str());
	else
	{
		logger().info("AggregationUTest failed!");
		logger().flush();
	}
}

void AggregationUTest::setUp()
{
	as = new AtomSpace();
	eval = new SchemeEval(as);
	eval->eval("(add-to-load-path \"" PROJECT_SOURCE_DIR "\")");
	ag = new Aggregate(as);
}

void AggregationUTest::tearDown()
{
	delete ag;
	delete eval;
	delete as;
}

void AggregationUTest::setup_dict()
{
	dict = new Dictionary(as);

	// The directions to connect.
	Handle plus = an(CONNECTOR_DIR_NODE, "+");
	Handle minus = an(CONNECTOR_DIR_NODE, "-");
	dict->add_pole_pair(plus, minus);
	dict->add_pole_pair(minus, plus);

	// The lexis to use
	HandleSet lex;
	as->get_handleset_by_type(lex, SECTION);
	dict->add_to_lexis(lex);
}

// Single generation: "Hello world"
void AggregationUTest::test_hello()
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

	eval->eval("(load-from-path \"tests/generate/dict-helloworld.scm\")");
	Handle wall = eval->eval_h("left-wall");

	setup_dict();
	DefaultCallback cb(as, *dict);
	Handle result = ag->aggregate({wall}, cb);

	TSM_ASSERT("Bad result!", result != Handle::UNDEFINED);

	// We expect the soultion to be LEFT_WALL --W--> Hello --OH--> world
	// printf("Hello-world result is  %s\n", result->to_string().c_str());
	logger().debug("Expecting 1 solution, got %d", result->get_arity());
	TSM_ASSERT("Bad result set!", result->get_arity() == 1);
	Handle soln = result->getOutgoingAtom(0);

	TSM_ASSERT("Bad section!", soln->get_arity() == 3);

	logger().debug("END TEST: %s", __FUNCTION__);
}

// Four generations: "John/Sue saw a bird/cat", as an acyclic tree.
void AggregationUTest::test_tree()
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

	eval->eval("(load-from-path \"tests/generate/dict-tree.scm\")");
	Handle wall = eval->eval_h("left-wall");

	setup_dict();
	DefaultCallback cb(as, *dict);

	Handle result = ag->aggregate({wall}, cb);

	TSM_ASSERT("Bad result!", result != Handle::UNDEFINED);

	// We expect the soultion to be loop-free (acyclic)
	//                    +----O-----+
	//    +--->W---+---S--+    +--D--+
	//    |        |      |    |     |
	// LEFT-WALL John    saw   a    cat
	//
	// printf("Tree result is  %s\n", result->to_string().c_str());

	logger().debug("Expecting 4 solutions, got %d", result->get_arity());
	TSM_ASSERT("Bad result set!", result->get_arity() == 4);

	// All of the solutions should be the same size, substituting
	// only John/Mary and dog/cat in the parse tree.
	int cnt = 0;
	for (const Handle& soln: result->getOutgoingSet())
	{
		logger().debug("   Soln %d expecting 5 links, got %d",
			++cnt, soln->get_arity());
		TSM_ASSERT("Bad section!", soln->get_arity() == 5);
	}

	logger().debug("END TEST: %s", __FUNCTION__);
}

// Four generations: "John/Sue saw a bird/cat", as graph w/ cycles.
// Currently failig due to inf recursion.
void AggregationUTest::test_loop()
{
	logger().debug("BEGIN TEST: %s", __FUNCTION__);

	eval->eval("(load-from-path \"tests/generate/dict-loop.scm\")");
	Handle wall = eval->eval_h("left-wall");

// logger().set_level(Logger::FINE);
	setup_dict();
	DefaultCallback cb(as, *dict);

	Handle result = ag->aggregate({wall}, cb);

	TSM_ASSERT("Bad result!", result != Handle::UNDEFINED);

	// We expect the soultion to be have a loop
	//    +-------WV------+----O-----+
	//    +--->W---+---S--+    +--D--+
	//    |        |      |    |     |
	// LEFT-WALL John    saw   a    cat
	//
	// printf("Loop result is %s\n", result->to_string().c_str());
	printf("Loop result size is %lu expecting 4\n", result->get_arity());
	TSM_ASSERT("Bad loop result set!", result->get_arity() == 4);
	Handle soln = result->getOutgoingAtom(0);

	printf("Loop section %s", soln->to_string().c_str());
	printf("Loop section size is %lu expecting 5\n", soln->get_arity());
	TSM_ASSERT("Bad section!", soln->get_arity() == 5);

	logger().debug("END TEST: %s", __FUNCTION__);
}
